// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../breez_sdk_common/input.dart';
import '../breez_sdk_common/lnurl/pay.dart';
import '../breez_sdk_common/network.dart';
import '../breez_sdk_spark.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `Credentials`, `OnchainConfirmationSpeed`, `SendOnchainFeeQuote`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `try_from`, `try_from`

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Fee>>
abstract class Fee implements RustOpaqueInterface {
  Future<BigInt> toSats({required BigInt vbytes});
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>
abstract class PaymentDetails implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PrepareSendPaymentResponse>>
abstract class PrepareSendPaymentResponse implements RustOpaqueInterface {
  BigInt get amountSats;

  SendPaymentMethod get paymentMethod;

  set amountSats(BigInt amountSats);

  set paymentMethod(SendPaymentMethod paymentMethod);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReceivePaymentMethod>>
abstract class ReceivePaymentMethod implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ReceivePaymentRequest>>
abstract class ReceivePaymentRequest implements RustOpaqueInterface {
  ReceivePaymentMethod get paymentMethod;

  set paymentMethod(ReceivePaymentMethod paymentMethod);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RefundDepositRequest>>
abstract class RefundDepositRequest implements RustOpaqueInterface {
  String get destinationAddress;

  Fee get fee;

  String get txid;

  int get vout;

  set destinationAddress(String destinationAddress);

  set fee(Fee fee);

  set txid(String txid);

  set vout(int vout);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SendPaymentMethod>>
abstract class SendPaymentMethod implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SendPaymentOptions>>
abstract class SendPaymentOptions implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SendPaymentRequest>>
abstract class SendPaymentRequest implements RustOpaqueInterface {
  SendPaymentOptions? get options;

  PrepareSendPaymentResponse get prepareResponse;

  set options(SendPaymentOptions? options);

  set prepareResponse(PrepareSendPaymentResponse prepareResponse);
}

abstract class Logger {
  Future<void> log({required LogEntry l});
}

class ClaimDepositRequest {
  final String txid;
  final int vout;
  final Fee? maxFee;

  const ClaimDepositRequest({required this.txid, required this.vout, this.maxFee});

  @override
  int get hashCode => txid.hashCode ^ vout.hashCode ^ maxFee.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ClaimDepositRequest &&
          runtimeType == other.runtimeType &&
          txid == other.txid &&
          vout == other.vout &&
          maxFee == other.maxFee;
}

class ClaimDepositResponse {
  final Payment payment;

  const ClaimDepositResponse({required this.payment});

  @override
  int get hashCode => payment.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ClaimDepositResponse && runtimeType == other.runtimeType && payment == other.payment;
}

class Config {
  final String? apiKey;
  final Network network;
  final int syncIntervalSecs;
  final Fee? maxDepositClaimFee;

  const Config({this.apiKey, required this.network, required this.syncIntervalSecs, this.maxDepositClaimFee});

  @override
  int get hashCode =>
      apiKey.hashCode ^ network.hashCode ^ syncIntervalSecs.hashCode ^ maxDepositClaimFee.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Config &&
          runtimeType == other.runtimeType &&
          apiKey == other.apiKey &&
          network == other.network &&
          syncIntervalSecs == other.syncIntervalSecs &&
          maxDepositClaimFee == other.maxDepositClaimFee;
}

class ConnectRequest {
  final Config config;
  final String mnemonic;
  final String storageDir;

  const ConnectRequest({required this.config, required this.mnemonic, required this.storageDir});

  @override
  int get hashCode => config.hashCode ^ mnemonic.hashCode ^ storageDir.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConnectRequest &&
          runtimeType == other.runtimeType &&
          config == other.config &&
          mnemonic == other.mnemonic &&
          storageDir == other.storageDir;
}

class DepositInfo {
  final String txid;
  final int vout;
  final BigInt amountSats;
  final String? refundTx;
  final String? refundTxId;
  final DepositClaimError? claimError;

  const DepositInfo({
    required this.txid,
    required this.vout,
    required this.amountSats,
    this.refundTx,
    this.refundTxId,
    this.claimError,
  });

  @override
  int get hashCode =>
      txid.hashCode ^
      vout.hashCode ^
      amountSats.hashCode ^
      refundTx.hashCode ^
      refundTxId.hashCode ^
      claimError.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DepositInfo &&
          runtimeType == other.runtimeType &&
          txid == other.txid &&
          vout == other.vout &&
          amountSats == other.amountSats &&
          refundTx == other.refundTx &&
          refundTxId == other.refundTxId &&
          claimError == other.claimError;
}

/// Request to get the balance of the wallet
class GetInfoRequest {
  const GetInfoRequest();

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) || other is GetInfoRequest && runtimeType == other.runtimeType;
}

/// Response containing the balance of the wallet
class GetInfoResponse {
  /// The balance in satoshis
  final BigInt balanceSats;

  const GetInfoResponse({required this.balanceSats});

  @override
  int get hashCode => balanceSats.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GetInfoResponse && runtimeType == other.runtimeType && balanceSats == other.balanceSats;
}

class GetPaymentRequest {
  final String paymentId;

  const GetPaymentRequest({required this.paymentId});

  @override
  int get hashCode => paymentId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GetPaymentRequest && runtimeType == other.runtimeType && paymentId == other.paymentId;
}

class GetPaymentResponse {
  final Payment payment;

  const GetPaymentResponse({required this.payment});

  @override
  int get hashCode => payment.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GetPaymentResponse && runtimeType == other.runtimeType && payment == other.payment;
}

/// Request to list payments with pagination
class ListPaymentsRequest {
  /// Number of records to skip
  final int? offset;

  /// Maximum number of records to return
  final int? limit;

  const ListPaymentsRequest({this.offset, this.limit});

  @override
  int get hashCode => offset.hashCode ^ limit.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ListPaymentsRequest &&
          runtimeType == other.runtimeType &&
          offset == other.offset &&
          limit == other.limit;
}

/// Response from listing payments
class ListPaymentsResponse {
  /// The list of payments
  final List<Payment> payments;

  const ListPaymentsResponse({required this.payments});

  @override
  int get hashCode => payments.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ListPaymentsResponse && runtimeType == other.runtimeType && payments == other.payments;
}

class ListUnclaimedDepositsRequest {
  const ListUnclaimedDepositsRequest();

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) || other is ListUnclaimedDepositsRequest && runtimeType == other.runtimeType;
}

class ListUnclaimedDepositsResponse {
  final List<DepositInfo> deposits;

  const ListUnclaimedDepositsResponse({required this.deposits});

  @override
  int get hashCode => deposits.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ListUnclaimedDepositsResponse &&
          runtimeType == other.runtimeType &&
          deposits == other.deposits;
}

/// Represents the payment LNURL info
class LnurlPayInfo {
  final String? lnAddress;
  final String? comment;
  final String? domain;
  final String? metadata;
  final SuccessActionProcessed? processedSuccessAction;
  final SuccessAction? rawSuccessAction;

  const LnurlPayInfo({
    this.lnAddress,
    this.comment,
    this.domain,
    this.metadata,
    this.processedSuccessAction,
    this.rawSuccessAction,
  });

  static Future<LnurlPayInfo> default_() => BreezSpark.instance.api.breezSdkSparkModelsLnurlPayInfoDefault();

  @override
  int get hashCode =>
      lnAddress.hashCode ^
      comment.hashCode ^
      domain.hashCode ^
      metadata.hashCode ^
      processedSuccessAction.hashCode ^
      rawSuccessAction.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnurlPayInfo &&
          runtimeType == other.runtimeType &&
          lnAddress == other.lnAddress &&
          comment == other.comment &&
          domain == other.domain &&
          metadata == other.metadata &&
          processedSuccessAction == other.processedSuccessAction &&
          rawSuccessAction == other.rawSuccessAction;
}

class LnurlPayRequest {
  final PrepareLnurlPayResponse prepareResponse;

  const LnurlPayRequest({required this.prepareResponse});

  @override
  int get hashCode => prepareResponse.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnurlPayRequest &&
          runtimeType == other.runtimeType &&
          prepareResponse == other.prepareResponse;
}

class LnurlPayResponse {
  final Payment payment;
  final SuccessActionProcessed? successAction;

  const LnurlPayResponse({required this.payment, this.successAction});

  @override
  int get hashCode => payment.hashCode ^ successAction.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LnurlPayResponse &&
          runtimeType == other.runtimeType &&
          payment == other.payment &&
          successAction == other.successAction;
}

class LogEntry {
  final String line;
  final String level;

  const LogEntry({required this.line, required this.level});

  @override
  int get hashCode => line.hashCode ^ level.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LogEntry && runtimeType == other.runtimeType && line == other.line && level == other.level;
}

enum Network { mainnet, regtest }

/// Represents a payment (sent or received)
class Payment {
  /// Unique identifier for the payment
  final String id;

  /// Type of payment (send or receive)
  final PaymentType paymentType;

  /// Status of the payment
  final PaymentStatus status;

  /// Amount in satoshis
  final BigInt amount;

  /// Fee paid in satoshis
  final BigInt fees;

  /// Timestamp of when the payment was created
  final BigInt timestamp;

  /// Method of payment. Sometimes the payment details is empty so this field
  /// is used to determine the payment method.
  final PaymentMethod method;

  /// Details of the payment
  final PaymentDetails? details;

  const Payment({
    required this.id,
    required this.paymentType,
    required this.status,
    required this.amount,
    required this.fees,
    required this.timestamp,
    required this.method,
    this.details,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      paymentType.hashCode ^
      status.hashCode ^
      amount.hashCode ^
      fees.hashCode ^
      timestamp.hashCode ^
      method.hashCode ^
      details.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Payment &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          paymentType == other.paymentType &&
          status == other.status &&
          amount == other.amount &&
          fees == other.fees &&
          timestamp == other.timestamp &&
          method == other.method &&
          details == other.details;
}

enum PaymentMethod { lightning, spark, deposit, withdraw, unknown }

/// The status of a payment
enum PaymentStatus {
  /// Payment is completed successfully
  completed,

  /// Payment is in progress
  pending,

  /// Payment has failed
  failed,
}

/// The type of payment
enum PaymentType {
  /// Payment sent from this wallet
  send,

  /// Payment received to this wallet
  receive,
}

class PrepareLnurlPayRequest {
  final BigInt amountSats;
  final LnurlPayRequestDetails payRequest;
  final String? comment;
  final bool? validateSuccessActionUrl;

  const PrepareLnurlPayRequest({
    required this.amountSats,
    required this.payRequest,
    this.comment,
    this.validateSuccessActionUrl,
  });

  @override
  int get hashCode =>
      amountSats.hashCode ^ payRequest.hashCode ^ comment.hashCode ^ validateSuccessActionUrl.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareLnurlPayRequest &&
          runtimeType == other.runtimeType &&
          amountSats == other.amountSats &&
          payRequest == other.payRequest &&
          comment == other.comment &&
          validateSuccessActionUrl == other.validateSuccessActionUrl;
}

class PrepareLnurlPayResponse {
  final BigInt amountSats;
  final String? comment;
  final LnurlPayRequestDetails payRequest;
  final BigInt feeSats;
  final Bolt11InvoiceDetails invoiceDetails;
  final SuccessAction? successAction;

  const PrepareLnurlPayResponse({
    required this.amountSats,
    this.comment,
    required this.payRequest,
    required this.feeSats,
    required this.invoiceDetails,
    this.successAction,
  });

  @override
  int get hashCode =>
      amountSats.hashCode ^
      comment.hashCode ^
      payRequest.hashCode ^
      feeSats.hashCode ^
      invoiceDetails.hashCode ^
      successAction.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareLnurlPayResponse &&
          runtimeType == other.runtimeType &&
          amountSats == other.amountSats &&
          comment == other.comment &&
          payRequest == other.payRequest &&
          feeSats == other.feeSats &&
          invoiceDetails == other.invoiceDetails &&
          successAction == other.successAction;
}

class PrepareSendPaymentRequest {
  final String paymentRequest;
  final BigInt? amountSats;

  const PrepareSendPaymentRequest({required this.paymentRequest, this.amountSats});

  @override
  int get hashCode => paymentRequest.hashCode ^ amountSats.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareSendPaymentRequest &&
          runtimeType == other.runtimeType &&
          paymentRequest == other.paymentRequest &&
          amountSats == other.amountSats;
}

class ReceivePaymentResponse {
  final String paymentRequest;
  final BigInt feeSats;

  const ReceivePaymentResponse({required this.paymentRequest, required this.feeSats});

  @override
  int get hashCode => paymentRequest.hashCode ^ feeSats.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReceivePaymentResponse &&
          runtimeType == other.runtimeType &&
          paymentRequest == other.paymentRequest &&
          feeSats == other.feeSats;
}

class RefundDepositResponse {
  final String txId;
  final String txHex;

  const RefundDepositResponse({required this.txId, required this.txHex});

  @override
  int get hashCode => txId.hashCode ^ txHex.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RefundDepositResponse &&
          runtimeType == other.runtimeType &&
          txId == other.txId &&
          txHex == other.txHex;
}

class SendOnchainSpeedFeeQuote {
  final BigInt userFeeSat;
  final BigInt l1BroadcastFeeSat;

  const SendOnchainSpeedFeeQuote({required this.userFeeSat, required this.l1BroadcastFeeSat});

  Future<BigInt> totalFeeSat() =>
      BreezSpark.instance.api.breezSdkSparkModelsSendOnchainSpeedFeeQuoteTotalFeeSat(that: this);

  @override
  int get hashCode => userFeeSat.hashCode ^ l1BroadcastFeeSat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SendOnchainSpeedFeeQuote &&
          runtimeType == other.runtimeType &&
          userFeeSat == other.userFeeSat &&
          l1BroadcastFeeSat == other.l1BroadcastFeeSat;
}

class SendPaymentResponse {
  final Payment payment;

  const SendPaymentResponse({required this.payment});

  @override
  int get hashCode => payment.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SendPaymentResponse && runtimeType == other.runtimeType && payment == other.payment;
}

/// Request to sync the wallet with the Spark network
class SyncWalletRequest {
  const SyncWalletRequest();

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) || other is SyncWalletRequest && runtimeType == other.runtimeType;
}

/// Response from synchronizing the wallet
class SyncWalletResponse {
  const SyncWalletResponse();

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) || other is SyncWalletResponse && runtimeType == other.runtimeType;
}
